// scripts/generate-client.js
import fs from 'fs';

// Default to local dev, but should be configurable
const WORKER_URL = process.env.WORKER_URL || "http://localhost:8787";
// Use demo token for generation if Auth is enabled
const MANIFEST_URL = `${WORKER_URL}/manifest?room_id=demo&token=demo-token`;

async function generate() {
  console.log(`üîÆ Fetching Manifest from ${MANIFEST_URL}...`);
  
  try {
    const res = await fetch(MANIFEST_URL);
    if (!res.ok) {
        const text = await res.text();
        throw new Error(`Failed to fetch manifest: ${res.status} ${text}. Ensure your Worker is running (npm run dev)`);
    }
    const { actions, tables } = await res.json();

    let output = `
// ‚ö†Ô∏è AUTO-GENERATED by nanotype
// Do not edit manually.

export interface RpcResponse<T = any> {
    data?: T;
    error?: string;
    type?: string;
}

export class NanoClient {
  private ws: WebSocket;
  private pending = new Map<string, (value: any) => void>();
  private messageQueue: string[] = [];
  private ready: boolean = false;

  constructor(url: string, token: string) {
    this.ws = new WebSocket(\`\${url}&token=\${token}\`);
    this.ws.onopen = () => {
        this.ready = true;
        this.flushQueue();
    };
    this.ws.onmessage = (e) => this.handleMessage(e);
  }

  private flushQueue() {
    while (this.messageQueue.length > 0) {
        this.ws.send(this.messageQueue.shift()!);
    }
  }

  private handleMessage(event: MessageEvent) {
    const data = JSON.parse(event.data);
    // In a real RPC implementation, we would match IDs.
    // Here we treat query_result as potential response for search
    if (data.type === 'mutation_success' || data.type === 'query_result') {
        // Dispatch event or resolve promise if ID matching was implemented
    }
  }

  private async call(method: string, payload: any): Promise<any> {
    const msg = JSON.stringify({ action: 'rpc', method, payload });
    if (this.ready) {
        this.ws.send(msg);
    } else {
        this.messageQueue.push(msg);
    }
    // For this simple generator, we return a promise that resolves immediately 
    // because the WebSocket is fire-and-forget in this demo architecture.
    // Real implementation would wait for response ID.
    return Promise.resolve();
  }
`;

    // 1. Generate Action Methods
    output += `\n  // --- ACTIONS ---\n`;
    for (const [name, config] of Object.entries(actions)) {
      const args = config.params.map(p => `${p}: any`).join(", ");
      const payloadBuilder = config.params.map(p => `${p}`).join(", ");
      
      output += `  async ${name}(${args}): Promise<any> {\n`;
      output += `    return this.call('${name}', { ${payloadBuilder} });\n`;
      output += `  }\n`;
    }

    output += `}\n`; // Close class
    
    // 2. Generate Schema Types
    output += `\n// --- SCHEMA ---\n`;
    if (tables) {
        for (const [tableName, columns] of Object.entries(tables)) {
            output += `export interface ${capitalize(tableName)} {\n`;
            columns.forEach(col => {
                let tsType = 'any';
                if (col.type.includes('INT')) tsType = 'number';
                if (col.type.includes('TEXT')) tsType = 'string';
                if (col.type.includes('BOOLEAN')) tsType = 'boolean';
                output += `  ${col.name}: ${tsType};\n`;
            });
            output += `}\n`;
        }
    }

    console.log("‚ú® Generating src/nanotype-client.ts...");
    fs.writeFileSync('src/nanotype-client.ts', output);
    console.log("‚úÖ Done! You can now use: client.createTask(...) and client.search(...)");

  } catch (err) {
    console.error("‚ùå Failed:", err.message);
  }
}

function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

generate();
