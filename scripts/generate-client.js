// scripts/generate-client.js
import fs from 'fs';

// Default to local dev, but should be configurable
const WORKER_URL = process.env.WORKER_URL || "http://localhost:8787";
// Use demo token for generation if Auth is enabled
const MANIFEST_URL = `${WORKER_URL}/manifest?room_id=demo&token=demo-token`;

async function generate() {
  console.log(`üîÆ Fetching Manifest from ${MANIFEST_URL}...`);
  
  try {
    const res = await fetch(MANIFEST_URL);
    if (!res.ok) {
        const text = await res.text();
        throw new Error(`Failed to fetch manifest: ${res.status} ${text}. Ensure your Worker is running (npm run dev)`);
    }
    const { actions, tables } = await res.json();

    let output = `
// ‚ö†Ô∏è AUTO-GENERATED by nanotype
// Do not edit manually.

export class NanoClient {
  private ws: WebSocket;
  private pending = new Map<string, (value: any) => void>();

  constructor(url: string, token: string) {
    this.ws = new WebSocket(\`\${url}&token=\${token}\`);
    this.ws.onmessage = (e) => this.handleMessage(e);
  }

  private handleMessage(event: MessageEvent) {
    const data = JSON.parse(event.data);
    // Handle RPC response if we add ID tracking to server responses (simplified for now)
    // For this demo, we assume fire-and-forget or specific success messages
    if (data.type === 'mutation_success') {
        // resolve specific promises if we tracked IDs
    }
  }

  private async call(method: string, payload: any) {
    if (this.ws.readyState !== WebSocket.OPEN) {
        await new Promise(resolve => {
            const h = () => { this.ws.removeEventListener('open', h); resolve(true); };
            this.ws.addEventListener('open', h);
        });
    }
    this.ws.send(JSON.stringify({ action: 'rpc', method, payload }));
  }
`;

    // 1. Generate Action Methods
    output += `\n  // --- ACTIONS ---\n`;
    for (const [name, config] of Object.entries(actions)) {
      const args = config.params.map(p => `${p}: any`).join(", ");
      const payloadBuilder = config.params.map(p => `${p}`).join(", ");
      
      output += `  async ${name}(${args}) {\n`;
      output += `    return this.call('${name}', { ${payloadBuilder} });\n`;
      output += `  }\n`;
    }

    output += `}\n`; // Close class
    
    // 2. Generate Schema Types
    output += `\n// --- SCHEMA ---\n`;
    for (const [tableName, columns] of Object.entries(tables)) {
        output += `export interface ${capitalize(tableName)} {\n`;
        columns.forEach(col => {
            let tsType = 'any';
            if (col.type.includes('INT')) tsType = 'number';
            if (col.type.includes('TEXT')) tsType = 'string';
            output += `  ${col.name}: ${tsType};\n`;
        });
        output += `}\n`;
    }

    console.log("‚ú® Generating src/nanotype-client.ts...");
    fs.writeFileSync('src/nanotype-client.ts', output);
    console.log("‚úÖ Done! You can now use: client.createTask(...)");

  } catch (err) {
    console.error("‚ùå Failed:", err.message);
  }
}

function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.slice(1);
}

generate();
