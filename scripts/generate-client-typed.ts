// scripts/generate-client-typed.ts
// Type-safe client generator using TypeScript Compiler API

import * as fs from 'fs';
import * as path from 'path';

// Default to local dev, but should be configurable
const WORKER_URL = process.env.WORKER_URL || "http://localhost:8787";
const MANIFEST_URL = `${WORKER_URL}/manifest?room_id=demo&token=demo-token`;

interface ActionConfig {
  params: string[];
}

interface ColumnInfo {
  cid: number;
  name: string;
  type: string;
  notnull: number;
  dflt_value: any;
  pk: number;
}

interface ManifestResponse {
  actions: Record<string, ActionConfig>;
  tables: Record<string, ColumnInfo[]>;
}

function sqlTypeToTsType(sqlType: string): string {
  const upperType = sqlType.toUpperCase();
  if (upperType.includes('INT')) return 'number';
  if (upperType.includes('REAL') || upperType.includes('FLOAT') || upperType.includes('DOUBLE')) return 'number';
  if (upperType.includes('TEXT') || upperType.includes('VARCHAR') || upperType.includes('CHAR')) return 'string';
  if (upperType.includes('BOOL')) return 'boolean';
  if (upperType.includes('BLOB')) return 'ArrayBuffer';
  return 'any';
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

// Shared utility for inferring TypeScript types from parameter names
const PARAM_TYPE_MAP: Record<string, string> = {
  'id': 'string | number',
  'limit': 'number',
  'offset': 'number',
  'query': 'string',
  'title': 'string',
  'text': 'string',
  'readonly': 'boolean',
  'userId': 'string',
  'position': 'string',
  'status': 'string',
  'sql': 'string',
  'key': 'string',
  'value': 'string',
  'topic': 'string',
  'description': 'string',
  'threshold': 'number',
  'url': 'string',
  'events': 'string',
  'secret': 'string',
  'active': 'boolean'
};

function inferParamType(paramName: string): string {
  return PARAM_TYPE_MAP[paramName] || 'any';
}

function generateClientCode(manifest: ManifestResponse): string {
  const { actions, tables } = manifest;
  
  // Start building the output
  const lines: string[] = [];
  
  // Header
  lines.push('// ‚ö†Ô∏è AUTO-GENERATED by nanotype (TypeScript-based generator)');
  lines.push('// Do not edit manually.');
  lines.push('');
  
  // RPC Response interface
  lines.push('export interface RpcResponse<T = any> {');
  lines.push('  data?: T;');
  lines.push('  error?: string;');
  lines.push('  type?: string;');
  lines.push('}');
  lines.push('');
  
  // Generate schema type interfaces first
  lines.push('// --- SCHEMA TYPES ---');
  if (tables) {
    for (const [tableName, columns] of Object.entries(tables)) {
      lines.push(`export interface ${capitalize(tableName)} {`);
      columns.forEach(col => {
        const tsType = sqlTypeToTsType(col.type);
        const nullable = col.notnull === 0 ? ' | null' : '';
        lines.push(`  ${col.name}: ${tsType}${nullable};`);
      });
      lines.push('}');
      lines.push('');
    }
  }
  
  // WebSocket message types
  lines.push('// --- MESSAGE TYPES ---');
  lines.push('export type WebSocketMessageType = ');
  lines.push('  | "mutation_success"');
  lines.push('  | "query_result"');
  lines.push('  | "table_update"');
  lines.push('  | "error"');
  lines.push('  | "pong"');
  lines.push('  | "reset";');
  lines.push('');
  
  lines.push('export interface WebSocketMessage {');
  lines.push('  type: WebSocketMessageType;');
  lines.push('  data?: any;');
  lines.push('  error?: string;');
  lines.push('  table?: string;');
  lines.push('  action?: "added" | "modified" | "deleted";');
  lines.push('  row?: any;');
  lines.push('}');
  lines.push('');
  
  // Generate action parameter interfaces
  lines.push('// --- ACTION PARAMETER TYPES ---');
  for (const [name, config] of Object.entries(actions)) {
    if (config.params.length > 0) {
      const interfaceName = `${capitalize(name)}Params`;
      lines.push(`export interface ${interfaceName} {`);
      
      config.params.forEach(param => {
        // Handle optional params (ending with ?)
        const isOptional = param.endsWith('?');
        const paramName = isOptional ? param.slice(0, -1) : param;
        const optional = isOptional ? '?' : '';
        
        const paramType = inferParamType(paramName);
        
        lines.push(`  ${paramName}${optional}: ${paramType};`);
      });
      
      lines.push('}');
      lines.push('');
    }
  }
  
  // Main client class
  lines.push('// --- NANO CLIENT ---');
  lines.push('export class NanoClient {');
  lines.push('  private ws: WebSocket;');
  lines.push('  private pending = new Map<string, (value: any) => void>();');
  lines.push('  private messageQueue: Array<{ id: string; message: string; resolve: (value: any) => void }> = [];');
  lines.push('  private ready: boolean = false;');
  lines.push('  private messageId: number = 0;');
  lines.push('  private listeners = new Map<string, Set<(data: any) => void>>();');
  lines.push('');
  
  // Constructor
  lines.push('  constructor(url: string, token: string) {');
  lines.push('    this.ws = new WebSocket(`${url}&token=${token}`);');
  lines.push('    this.ws.onopen = () => {');
  lines.push('      this.ready = true;');
  lines.push('      this.flushQueue();');
  lines.push('    };');
  lines.push('    this.ws.onmessage = (e) => this.handleMessage(e);');
  lines.push('    this.ws.onerror = (error) => console.error("WebSocket error:", error);');
  lines.push('    this.ws.onclose = () => {');
  lines.push('      this.ready = false;');
  lines.push('      console.log("WebSocket closed");');
  lines.push('    };');
  lines.push('  }');
  lines.push('');
  
  // Flush queue method
  lines.push('  private flushQueue() {');
  lines.push('    while (this.messageQueue.length > 0) {');
  lines.push('      const item = this.messageQueue.shift()!;');
  lines.push('      this.pending.set(item.id, item.resolve);');
  lines.push('      this.ws.send(item.message);');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  
  // Handle message method
  lines.push('  private handleMessage(event: MessageEvent) {');
  lines.push('    const data = JSON.parse(event.data) as WebSocketMessage;');
  lines.push('');
  lines.push('    // Handle table updates');
  lines.push('    if (data.type === "table_update" && data.table) {');
  lines.push('      const listeners = this.listeners.get(data.table);');
  lines.push('      if (listeners) {');
  lines.push('        listeners.forEach(callback => callback(data));');
  lines.push('      }');
  lines.push('    }');
  lines.push('');
  lines.push('    // Handle RPC responses (mutation_success, query_result)');
  lines.push('    if (data.type === "mutation_success" || data.type === "query_result") {');
  lines.push('      // In a real implementation with message IDs, match and resolve promises');
  lines.push('      // For now, resolve all pending promises');
  lines.push('      this.pending.forEach(resolve => resolve(data));');
  lines.push('      this.pending.clear();');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  
  // Subscribe method
  lines.push('  subscribe(table: string, callback: (data: WebSocketMessage) => void): () => void {');
  lines.push('    if (!this.listeners.has(table)) {');
  lines.push('      this.listeners.set(table, new Set());');
  lines.push('    }');
  lines.push('    this.listeners.get(table)!.add(callback);');
  lines.push('');
  lines.push('    // Send subscribe message to server');
  lines.push('    const msg = JSON.stringify({ action: "subscribe", table });');
  lines.push('    if (this.ready) {');
  lines.push('      this.ws.send(msg);');
  lines.push('    }');
  lines.push('');
  lines.push('    // Return unsubscribe function');
  lines.push('    return () => {');
  lines.push('      const listeners = this.listeners.get(table);');
  lines.push('      if (listeners) {');
  lines.push('        listeners.delete(callback);');
  lines.push('      }');
  lines.push('    };');
  lines.push('  }');
  lines.push('');
  
  // Call method
  lines.push('  private async call<T = any>(method: string, payload: any): Promise<RpcResponse<T>> {');
  lines.push('    const id = `msg_${this.messageId++}`;');
  lines.push('    const msg = JSON.stringify({ action: "rpc", method, payload, id });');
  lines.push('');
  lines.push('    return new Promise<RpcResponse<T>>((resolve) => {');
  lines.push('      if (this.ready) {');
  lines.push('        this.pending.set(id, resolve);');
  lines.push('        this.ws.send(msg);');
  lines.push('      } else {');
  lines.push('        this.messageQueue.push({ id, message: msg, resolve });');
  lines.push('      }');
  lines.push('');
  lines.push('      // Timeout after 30 seconds');
  lines.push('      setTimeout(() => {');
  lines.push('        if (this.pending.has(id)) {');
  lines.push('          this.pending.delete(id);');
  lines.push('          resolve({ error: "Request timeout" });');
  lines.push('        }');
  lines.push('      }, 30000);');
  lines.push('    });');
  lines.push('  }');
  lines.push('');
  
  // Generate typed action methods
  lines.push('  // --- TYPED ACTION METHODS ---');
  for (const [name, config] of Object.entries(actions)) {
    const hasParams = config.params.length > 0;
    const paramsInterfaceName = hasParams ? `${capitalize(name)}Params` : '';
    
    if (hasParams) {
      lines.push(`  async ${name}(params: ${paramsInterfaceName}): Promise<RpcResponse> {`);
      lines.push(`    return this.call('${name}', params);`);
    } else {
      lines.push(`  async ${name}(): Promise<RpcResponse> {`);
      lines.push(`    return this.call('${name}', {});`);
    }
    lines.push(`  }`);
    lines.push('');
  }
  
  // Close method
  lines.push('  close() {');
  lines.push('    this.ws.close();');
  lines.push('  }');
  lines.push('}');
  
  return lines.join('\n');
}

async function generate() {
  console.log(`üîÆ Fetching Manifest from ${MANIFEST_URL}...`);
  
  try {
    const res = await fetch(MANIFEST_URL);
    if (!res.ok) {
      const text = await res.text();
      throw new Error(`Failed to fetch manifest: ${res.status} ${text}. Ensure your Worker is running (npm run dev)`);
    }
    
    const manifest = await res.json() as ManifestResponse;
    const clientCode = generateClientCode(manifest);
    
    const outputPath = path.join(process.cwd(), 'src', 'nanotype-client.ts');
    console.log(`‚ú® Generating ${outputPath}...`);
    fs.writeFileSync(outputPath, clientCode);
    console.log("‚úÖ Done! Type-safe client generated with:");
    console.log(`   - ${Object.keys(manifest.actions).length} typed action methods`);
    console.log(`   - ${Object.keys(manifest.tables || {}).length} schema interfaces`);
    console.log(`   - Full TypeScript type safety`);
    
  } catch (err: any) {
    console.error("‚ùå Failed:", err.message);
    process.exit(1);
  }
}

generate();
