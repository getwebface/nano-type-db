// src/client-generator.ts
// Type-safe client generator for use in the worker

interface ActionConfig {
  params: string[];
}

interface ColumnInfo {
  cid: number;
  name: string;
  type: string;
  notnull: number;
  dflt_value: any;
  pk: number;
}

function sqlTypeToTsType(sqlType: string): string {
  const upperType = sqlType.toUpperCase();
  if (upperType.includes('INT')) return 'number';
  if (upperType.includes('REAL') || upperType.includes('FLOAT') || upperType.includes('DOUBLE')) return 'number';
  if (upperType.includes('TEXT') || upperType.includes('VARCHAR') || upperType.includes('CHAR')) return 'string';
  if (upperType.includes('BOOL')) return 'boolean';
  if (upperType.includes('BLOB')) return 'ArrayBuffer';
  return 'any';
}

function capitalize(s: string): string {
  return s.charAt(0).toUpperCase() + s.slice(1);
}

export function generateTypeSafeClient(
  actions: Record<string, ActionConfig>,
  tables: Record<string, ColumnInfo[]>
): string {
  const lines: string[] = [];
  
  // Header
  lines.push('// ⚠️ AUTO-GENERATED by nanotype (TypeScript-based generator)');
  lines.push('// Do not edit manually.');
  lines.push('');
  
  // RPC Response interface
  lines.push('export interface RpcResponse<T = any> {');
  lines.push('  data?: T;');
  lines.push('  error?: string;');
  lines.push('  type?: string;');
  lines.push('}');
  lines.push('');
  
  // Generate schema type interfaces first
  lines.push('// --- SCHEMA TYPES ---');
  if (tables) {
    for (const [tableName, columns] of Object.entries(tables)) {
      lines.push(`export interface ${capitalize(tableName)} {`);
      columns.forEach(col => {
        const tsType = sqlTypeToTsType(col.type);
        const nullable = col.notnull === 0 ? ' | null' : '';
        lines.push(`  ${col.name}: ${tsType}${nullable};`);
      });
      lines.push('}');
      lines.push('');
    }
  }
  
  // WebSocket message types
  lines.push('// --- MESSAGE TYPES ---');
  lines.push('export type WebSocketMessageType = ');
  lines.push('  | "mutation_success"');
  lines.push('  | "query_result"');
  lines.push('  | "table_update"');
  lines.push('  | "error"');
  lines.push('  | "pong"');
  lines.push('  | "reset";');
  lines.push('');
  
  lines.push('export interface WebSocketMessage {');
  lines.push('  type: WebSocketMessageType;');
  lines.push('  data?: any;');
  lines.push('  error?: string;');
  lines.push('  table?: string;');
  lines.push('  action?: "added" | "modified" | "deleted";');
  lines.push('  row?: any;');
  lines.push('}');
  lines.push('');
  
  // Generate action parameter interfaces
  lines.push('// --- ACTION PARAMETER TYPES ---');
  for (const [name, config] of Object.entries(actions)) {
    if (config.params.length > 0) {
      const interfaceName = `${capitalize(name)}Params`;
      lines.push(`export interface ${interfaceName} {`);
      
      config.params.forEach(param => {
        // Handle optional params (ending with ?)
        const isOptional = param.endsWith('?');
        const paramName = isOptional ? param.slice(0, -1) : param;
        const optional = isOptional ? '?' : '';
        
        // Try to infer types from common parameter names
        let paramType = 'any';
        if (paramName === 'id') paramType = 'string | number';
        else if (paramName === 'limit' || paramName === 'offset') paramType = 'number';
        else if (paramName === 'query' || paramName === 'title' || paramName === 'text') paramType = 'string';
        else if (paramName === 'readonly') paramType = 'boolean';
        else if (paramName === 'userId' || paramName === 'position' || paramName === 'status') paramType = 'string';
        else if (paramName === 'sql') paramType = 'string';
        else if (paramName === 'key' || paramName === 'value') paramType = 'string';
        else if (paramName === 'topic' || paramName === 'description') paramType = 'string';
        else if (paramName === 'threshold') paramType = 'number';
        
        lines.push(`  ${paramName}${optional}: ${paramType};`);
      });
      
      lines.push('}');
      lines.push('');
    }
  }
  
  // Main client class
  lines.push('// --- NANO CLIENT ---');
  lines.push('export class NanoClient {');
  lines.push('  private ws: WebSocket;');
  lines.push('  private pending = new Map<string, (value: any) => void>();');
  lines.push('  private messageQueue: Array<{ id: string; message: string; resolve: (value: any) => void }> = [];');
  lines.push('  private ready: boolean = false;');
  lines.push('  private messageId: number = 0;');
  lines.push('  private listeners = new Map<string, Set<(data: any) => void>>();');
  lines.push('');
  
  // Constructor
  lines.push('  constructor(url: string, token: string) {');
  lines.push('    this.ws = new WebSocket(`${url}&token=${token}`);');
  lines.push('    this.ws.onopen = () => {');
  lines.push('      this.ready = true;');
  lines.push('      this.flushQueue();');
  lines.push('    };');
  lines.push('    this.ws.onmessage = (e) => this.handleMessage(e);');
  lines.push('    this.ws.onerror = (error) => console.error("WebSocket error:", error);');
  lines.push('    this.ws.onclose = () => {');
  lines.push('      this.ready = false;');
  lines.push('      console.log("WebSocket closed");');
  lines.push('    };');
  lines.push('  }');
  lines.push('');
  
  // Flush queue method
  lines.push('  private flushQueue() {');
  lines.push('    while (this.messageQueue.length > 0) {');
  lines.push('      const item = this.messageQueue.shift()!;');
  lines.push('      this.pending.set(item.id, item.resolve);');
  lines.push('      this.ws.send(item.message);');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  
  // Handle message method
  lines.push('  private handleMessage(event: MessageEvent) {');
  lines.push('    const data = JSON.parse(event.data) as WebSocketMessage;');
  lines.push('');
  lines.push('    // Handle table updates');
  lines.push('    if (data.type === "table_update" && data.table) {');
  lines.push('      const listeners = this.listeners.get(data.table);');
  lines.push('      if (listeners) {');
  lines.push('        listeners.forEach(callback => callback(data));');
  lines.push('      }');
  lines.push('    }');
  lines.push('');
  lines.push('    // Handle RPC responses (mutation_success, query_result)');
  lines.push('    if (data.type === "mutation_success" || data.type === "query_result") {');
  lines.push('      // In a real implementation with message IDs, match and resolve promises');
  lines.push('      // For now, resolve all pending promises');
  lines.push('      this.pending.forEach(resolve => resolve(data));');
  lines.push('      this.pending.clear();');
  lines.push('    }');
  lines.push('  }');
  lines.push('');
  
  // Subscribe method
  lines.push('  subscribe(table: string, callback: (data: WebSocketMessage) => void): () => void {');
  lines.push('    if (!this.listeners.has(table)) {');
  lines.push('      this.listeners.set(table, new Set());');
  lines.push('    }');
  lines.push('    this.listeners.get(table)!.add(callback);');
  lines.push('');
  lines.push('    // Send subscribe message to server');
  lines.push('    const msg = JSON.stringify({ action: "subscribe", table });');
  lines.push('    if (this.ready) {');
  lines.push('      this.ws.send(msg);');
  lines.push('    }');
  lines.push('');
  lines.push('    // Return unsubscribe function');
  lines.push('    return () => {');
  lines.push('      const listeners = this.listeners.get(table);');
  lines.push('      if (listeners) {');
  lines.push('        listeners.delete(callback);');
  lines.push('      }');
  lines.push('    };');
  lines.push('  }');
  lines.push('');
  
  // Call method
  lines.push('  private async call<T = any>(method: string, payload: any): Promise<RpcResponse<T>> {');
  lines.push('    const id = `msg_${this.messageId++}`;');
  lines.push('    const msg = JSON.stringify({ action: "rpc", method, payload, id });');
  lines.push('');
  lines.push('    return new Promise<RpcResponse<T>>((resolve) => {');
  lines.push('      if (this.ready) {');
  lines.push('        this.pending.set(id, resolve);');
  lines.push('        this.ws.send(msg);');
  lines.push('      } else {');
  lines.push('        this.messageQueue.push({ id, message: msg, resolve });');
  lines.push('      }');
  lines.push('');
  lines.push('      // Timeout after 30 seconds');
  lines.push('      setTimeout(() => {');
  lines.push('        if (this.pending.has(id)) {');
  lines.push('          this.pending.delete(id);');
  lines.push('          resolve({ error: "Request timeout" });');
  lines.push('        }');
  lines.push('      }, 30000);');
  lines.push('    });');
  lines.push('  }');
  lines.push('');
  
  // Generate typed action methods
  lines.push('  // --- TYPED ACTION METHODS ---');
  for (const [name, config] of Object.entries(actions)) {
    const hasParams = config.params.length > 0;
    const paramsInterfaceName = hasParams ? `${capitalize(name)}Params` : '';
    
    if (hasParams) {
      lines.push(`  async ${name}(params: ${paramsInterfaceName}): Promise<RpcResponse> {`);
      lines.push(`    return this.call('${name}', params);`);
    } else {
      lines.push(`  async ${name}(): Promise<RpcResponse> {`);
      lines.push(`    return this.call('${name}', {});`);
    }
    lines.push(`  }`);
    lines.push('');
  }
  
  // Close method
  lines.push('  close() {');
  lines.push('    this.ws.close();');
  lines.push('  }');
  lines.push('}');
  
  return lines.join('\n');
}
